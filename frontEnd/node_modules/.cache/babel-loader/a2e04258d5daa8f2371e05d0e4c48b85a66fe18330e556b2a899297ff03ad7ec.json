{"ast":null,"code":"// https://d3js.org/d3-array/ v2.12.1 Copyright 2021 Mike Bostock\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.d3 = global.d3 || {}));\n})(this, function (exports) {\n  'use strict';\n\n  function ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  function bisector(f) {\n    let delta = f;\n    let compare = f;\n    if (f.length === 1) {\n      delta = (d, x) => f(d) - x;\n      compare = ascendingComparator(f);\n    }\n    function left(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n      }\n      return lo;\n    }\n    function right(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n      }\n      return lo;\n    }\n    function center(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      const i = left(a, x, lo, hi - 1);\n      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n    }\n    return {\n      left,\n      center,\n      right\n    };\n  }\n  function ascendingComparator(f) {\n    return (d, x) => ascending(f(d), x);\n  }\n  function number(x) {\n    return x === null ? NaN : +x;\n  }\n  function* numbers(values, valueof) {\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value != null && (value = +value) >= value) {\n          yield value;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n          yield value;\n        }\n      }\n    }\n  }\n  const ascendingBisect = bisector(ascending);\n  const bisectRight = ascendingBisect.right;\n  const bisectLeft = ascendingBisect.left;\n  const bisectCenter = bisector(number).center;\n  function count(values, valueof) {\n    let count = 0;\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value != null && (value = +value) >= value) {\n          ++count;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n          ++count;\n        }\n      }\n    }\n    return count;\n  }\n  function length$1(array) {\n    return array.length | 0;\n  }\n  function empty(length) {\n    return !(length > 0);\n  }\n  function arrayify(values) {\n    return typeof values !== \"object\" || \"length\" in values ? values : Array.from(values);\n  }\n  function reducer(reduce) {\n    return values => reduce(...values);\n  }\n  function cross(...values) {\n    const reduce = typeof values[values.length - 1] === \"function\" && reducer(values.pop());\n    values = values.map(arrayify);\n    const lengths = values.map(length$1);\n    const j = values.length - 1;\n    const index = new Array(j + 1).fill(0);\n    const product = [];\n    if (j < 0 || lengths.some(empty)) return product;\n    while (true) {\n      product.push(index.map((j, i) => values[i][j]));\n      let i = j;\n      while (++index[i] === lengths[i]) {\n        if (i === 0) return reduce ? product.map(reduce) : product;\n        index[i--] = 0;\n      }\n    }\n  }\n  function cumsum(values, valueof) {\n    var sum = 0,\n      index = 0;\n    return Float64Array.from(values, valueof === undefined ? v => sum += +v || 0 : v => sum += +valueof(v, index++, values) || 0);\n  }\n  function descending(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  }\n  function variance(values, valueof) {\n    let count = 0;\n    let delta;\n    let mean = 0;\n    let sum = 0;\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value != null && (value = +value) >= value) {\n          delta = value - mean;\n          mean += delta / ++count;\n          sum += delta * (value - mean);\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n          delta = value - mean;\n          mean += delta / ++count;\n          sum += delta * (value - mean);\n        }\n      }\n    }\n    if (count > 1) return sum / (count - 1);\n  }\n  function deviation(values, valueof) {\n    const v = variance(values, valueof);\n    return v ? Math.sqrt(v) : v;\n  }\n  function extent(values, valueof) {\n    let min;\n    let max;\n    if (valueof === undefined) {\n      for (const value of values) {\n        if (value != null) {\n          if (min === undefined) {\n            if (value >= value) min = max = value;\n          } else {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null) {\n          if (min === undefined) {\n            if (value >= value) min = max = value;\n          } else {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n    return [min, max];\n  }\n\n  // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423\n  class Adder {\n    constructor() {\n      this._partials = new Float64Array(32);\n      this._n = 0;\n    }\n    add(x) {\n      const p = this._partials;\n      let i = 0;\n      for (let j = 0; j < this._n && j < 32; j++) {\n        const y = p[j],\n          hi = x + y,\n          lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);\n        if (lo) p[i++] = lo;\n        x = hi;\n      }\n      p[i] = x;\n      this._n = i + 1;\n      return this;\n    }\n    valueOf() {\n      const p = this._partials;\n      let n = this._n,\n        x,\n        y,\n        lo,\n        hi = 0;\n      if (n > 0) {\n        hi = p[--n];\n        while (n > 0) {\n          x = hi;\n          y = p[--n];\n          hi = x + y;\n          lo = y - (hi - x);\n          if (lo) break;\n        }\n        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {\n          y = lo * 2;\n          x = hi + y;\n          if (y == x - hi) hi = x;\n        }\n      }\n      return hi;\n    }\n  }\n  function fsum(values, valueof) {\n    const adder = new Adder();\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value = +value) {\n          adder.add(value);\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if (value = +valueof(value, ++index, values)) {\n          adder.add(value);\n        }\n      }\n    }\n    return +adder;\n  }\n  function fcumsum(values, valueof) {\n    const adder = new Adder();\n    let index = -1;\n    return Float64Array.from(values, valueof === undefined ? v => adder.add(+v || 0) : v => adder.add(+valueof(v, ++index, values) || 0));\n  }\n  class InternMap extends Map {\n    constructor(entries, key = keyof) {\n      super();\n      Object.defineProperties(this, {\n        _intern: {\n          value: new Map()\n        },\n        _key: {\n          value: key\n        }\n      });\n      if (entries != null) for (const [key, value] of entries) this.set(key, value);\n    }\n    get(key) {\n      return super.get(intern_get(this, key));\n    }\n    has(key) {\n      return super.has(intern_get(this, key));\n    }\n    set(key, value) {\n      return super.set(intern_set(this, key), value);\n    }\n    delete(key) {\n      return super.delete(intern_delete(this, key));\n    }\n  }\n  class InternSet extends Set {\n    constructor(values, key = keyof) {\n      super();\n      Object.defineProperties(this, {\n        _intern: {\n          value: new Map()\n        },\n        _key: {\n          value: key\n        }\n      });\n      if (values != null) for (const value of values) this.add(value);\n    }\n    has(value) {\n      return super.has(intern_get(this, value));\n    }\n    add(value) {\n      return super.add(intern_set(this, value));\n    }\n    delete(value) {\n      return super.delete(intern_delete(this, value));\n    }\n  }\n  function intern_get({\n    _intern,\n    _key\n  }, value) {\n    const key = _key(value);\n    return _intern.has(key) ? _intern.get(key) : value;\n  }\n  function intern_set({\n    _intern,\n    _key\n  }, value) {\n    const key = _key(value);\n    if (_intern.has(key)) return _intern.get(key);\n    _intern.set(key, value);\n    return value;\n  }\n  function intern_delete({\n    _intern,\n    _key\n  }, value) {\n    const key = _key(value);\n    if (_intern.has(key)) {\n      value = _intern.get(value);\n      _intern.delete(key);\n    }\n    return value;\n  }\n  function keyof(value) {\n    return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n  }\n  function identity(x) {\n    return x;\n  }\n  function group(values, ...keys) {\n    return nest(values, identity, identity, keys);\n  }\n  function groups(values, ...keys) {\n    return nest(values, Array.from, identity, keys);\n  }\n  function rollup(values, reduce, ...keys) {\n    return nest(values, identity, reduce, keys);\n  }\n  function rollups(values, reduce, ...keys) {\n    return nest(values, Array.from, reduce, keys);\n  }\n  function index(values, ...keys) {\n    return nest(values, identity, unique, keys);\n  }\n  function indexes(values, ...keys) {\n    return nest(values, Array.from, unique, keys);\n  }\n  function unique(values) {\n    if (values.length !== 1) throw new Error(\"duplicate key\");\n    return values[0];\n  }\n  function nest(values, map, reduce, keys) {\n    return function regroup(values, i) {\n      if (i >= keys.length) return reduce(values);\n      const groups = new InternMap();\n      const keyof = keys[i++];\n      let index = -1;\n      for (const value of values) {\n        const key = keyof(value, ++index, values);\n        const group = groups.get(key);\n        if (group) group.push(value);else groups.set(key, [value]);\n      }\n      for (const [key, values] of groups) {\n        groups.set(key, regroup(values, i));\n      }\n      return map(groups);\n    }(values, 0);\n  }\n  function permute(source, keys) {\n    return Array.from(keys, key => source[key]);\n  }\n  function sort(values, ...F) {\n    if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n    values = Array.from(values);\n    let [f = ascending] = F;\n    if (f.length === 1 || F.length > 1) {\n      const index = Uint32Array.from(values, (d, i) => i);\n      if (F.length > 1) {\n        F = F.map(f => values.map(f));\n        index.sort((i, j) => {\n          for (const f of F) {\n            const c = ascending(f[i], f[j]);\n            if (c) return c;\n          }\n        });\n      } else {\n        f = values.map(f);\n        index.sort((i, j) => ascending(f[i], f[j]));\n      }\n      return permute(values, index);\n    }\n    return values.sort(f);\n  }\n  function groupSort(values, reduce, key) {\n    return (reduce.length === 1 ? sort(rollup(values, reduce, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values, key), ([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))).map(([key]) => key);\n  }\n  var array = Array.prototype;\n  var slice = array.slice;\n  function constant(x) {\n    return function () {\n      return x;\n    };\n  }\n  var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n  function ticks(start, stop, count) {\n    var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n    stop = +stop, start = +start, count = +count;\n    if (start === stop && count > 0) return [start];\n    if (reverse = stop < start) n = start, start = stop, stop = n;\n    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n    if (step > 0) {\n      let r0 = Math.round(start / step),\n        r1 = Math.round(stop / step);\n      if (r0 * step < start) ++r0;\n      if (r1 * step > stop) --r1;\n      ticks = new Array(n = r1 - r0 + 1);\n      while (++i < n) ticks[i] = (r0 + i) * step;\n    } else {\n      step = -step;\n      let r0 = Math.round(start * step),\n        r1 = Math.round(stop * step);\n      if (r0 / step < start) ++r0;\n      if (r1 / step > stop) --r1;\n      ticks = new Array(n = r1 - r0 + 1);\n      while (++i < n) ticks[i] = (r0 + i) / step;\n    }\n    if (reverse) ticks.reverse();\n    return ticks;\n  }\n  function tickIncrement(start, stop, count) {\n    var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n  }\n  function tickStep(start, stop, count) {\n    var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n    if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;\n    return stop < start ? -step1 : step1;\n  }\n  function nice(start, stop, count) {\n    let prestep;\n    while (true) {\n      const step = tickIncrement(start, stop, count);\n      if (step === prestep || step === 0 || !isFinite(step)) {\n        return [start, stop];\n      } else if (step > 0) {\n        start = Math.floor(start / step) * step;\n        stop = Math.ceil(stop / step) * step;\n      } else if (step < 0) {\n        start = Math.ceil(start * step) / step;\n        stop = Math.floor(stop * step) / step;\n      }\n      prestep = step;\n    }\n  }\n  function sturges(values) {\n    return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;\n  }\n  function bin() {\n    var value = identity,\n      domain = extent,\n      threshold = sturges;\n    function histogram(data) {\n      if (!Array.isArray(data)) data = Array.from(data);\n      var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n      for (i = 0; i < n; ++i) {\n        values[i] = value(data[i], i, data);\n      }\n      var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n      // Convert number of thresholds into uniform thresholds, and nice the\n      // default domain accordingly.\n      if (!Array.isArray(tz)) {\n        const max = x1,\n          tn = +tz;\n        if (domain === extent) [x0, x1] = nice(x0, x1, tn);\n        tz = ticks(x0, x1, tn);\n\n        // If the last threshold is coincident with the domain’s upper bound, the\n        // last bin will be zero-width. If the default domain is used, and this\n        // last threshold is coincident with the maximum input value, we can\n        // extend the niced upper bound by one tick to ensure uniform bin widths;\n        // otherwise, we simply remove the last threshold. Note that we don’t\n        // coerce values or the domain to numbers, and thus must be careful to\n        // compare order (>=) rather than strict equality (===)!\n        if (tz[tz.length - 1] >= x1) {\n          if (max >= x1 && domain === extent) {\n            const step = tickIncrement(x0, x1, tn);\n            if (isFinite(step)) {\n              if (step > 0) {\n                x1 = (Math.floor(x1 / step) + 1) * step;\n              } else if (step < 0) {\n                x1 = (Math.ceil(x1 * -step) + 1) / -step;\n              }\n            }\n          } else {\n            tz.pop();\n          }\n        }\n      }\n\n      // Remove any thresholds outside the domain.\n      var m = tz.length;\n      while (tz[0] <= x0) tz.shift(), --m;\n      while (tz[m - 1] > x1) tz.pop(), --m;\n      var bins = new Array(m + 1),\n        bin;\n\n      // Initialize bins.\n      for (i = 0; i <= m; ++i) {\n        bin = bins[i] = [];\n        bin.x0 = i > 0 ? tz[i - 1] : x0;\n        bin.x1 = i < m ? tz[i] : x1;\n      }\n\n      // Assign data to bins by value, ignoring any outside the domain.\n      for (i = 0; i < n; ++i) {\n        x = values[i];\n        if (x0 <= x && x <= x1) {\n          bins[bisectRight(tz, x, 0, m)].push(data[i]);\n        }\n      }\n      return bins;\n    }\n    histogram.value = function (_) {\n      return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n    };\n    histogram.domain = function (_) {\n      return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n    };\n    histogram.thresholds = function (_) {\n      return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n    };\n    return histogram;\n  }\n  function max(values, valueof) {\n    let max;\n    if (valueof === undefined) {\n      for (const value of values) {\n        if (value != null && (max < value || max === undefined && value >= value)) {\n          max = value;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (max < value || max === undefined && value >= value)) {\n          max = value;\n        }\n      }\n    }\n    return max;\n  }\n  function min(values, valueof) {\n    let min;\n    if (valueof === undefined) {\n      for (const value of values) {\n        if (value != null && (min > value || min === undefined && value >= value)) {\n          min = value;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (min > value || min === undefined && value >= value)) {\n          min = value;\n        }\n      }\n    }\n    return min;\n  }\n\n  // Based on https://github.com/mourner/quickselect\n  // ISC license, Copyright 2018 Vladimir Agafonkin.\n  function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {\n    while (right > left) {\n      if (right - left > 600) {\n        const n = right - left + 1;\n        const m = k - left + 1;\n        const z = Math.log(n);\n        const s = 0.5 * Math.exp(2 * z / 3);\n        const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        quickselect(array, k, newLeft, newRight, compare);\n      }\n      const t = array[k];\n      let i = left;\n      let j = right;\n      swap(array, left, k);\n      if (compare(array[right], t) > 0) swap(array, left, right);\n      while (i < j) {\n        swap(array, i, j), ++i, --j;\n        while (compare(array[i], t) < 0) ++i;\n        while (compare(array[j], t) > 0) --j;\n      }\n      if (compare(array[left], t) === 0) swap(array, left, j);else ++j, swap(array, j, right);\n      if (j <= k) left = j + 1;\n      if (k <= j) right = j - 1;\n    }\n    return array;\n  }\n  function swap(array, i, j) {\n    const t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n  }\n  function quantile(values, p, valueof) {\n    values = Float64Array.from(numbers(values, valueof));\n    if (!(n = values.length)) return;\n    if ((p = +p) <= 0 || n < 2) return min(values);\n    if (p >= 1) return max(values);\n    var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n    return value0 + (value1 - value0) * (i - i0);\n  }\n  function quantileSorted(values, p, valueof = number) {\n    if (!(n = values.length)) return;\n    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n    if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n    var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n    return value0 + (value1 - value0) * (i - i0);\n  }\n  function freedmanDiaconis(values, min, max) {\n    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));\n  }\n  function scott(values, min, max) {\n    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));\n  }\n  function maxIndex(values, valueof) {\n    let max;\n    let maxIndex = -1;\n    let index = -1;\n    if (valueof === undefined) {\n      for (const value of values) {\n        ++index;\n        if (value != null && (max < value || max === undefined && value >= value)) {\n          max = value, maxIndex = index;\n        }\n      }\n    } else {\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (max < value || max === undefined && value >= value)) {\n          max = value, maxIndex = index;\n        }\n      }\n    }\n    return maxIndex;\n  }\n  function mean(values, valueof) {\n    let count = 0;\n    let sum = 0;\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value != null && (value = +value) >= value) {\n          ++count, sum += value;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n          ++count, sum += value;\n        }\n      }\n    }\n    if (count) return sum / count;\n  }\n  function median(values, valueof) {\n    return quantile(values, 0.5, valueof);\n  }\n  function* flatten(arrays) {\n    for (const array of arrays) {\n      yield* array;\n    }\n  }\n  function merge(arrays) {\n    return Array.from(flatten(arrays));\n  }\n  function minIndex(values, valueof) {\n    let min;\n    let minIndex = -1;\n    let index = -1;\n    if (valueof === undefined) {\n      for (const value of values) {\n        ++index;\n        if (value != null && (min > value || min === undefined && value >= value)) {\n          min = value, minIndex = index;\n        }\n      }\n    } else {\n      for (let value of values) {\n        if ((value = valueof(value, ++index, values)) != null && (min > value || min === undefined && value >= value)) {\n          min = value, minIndex = index;\n        }\n      }\n    }\n    return minIndex;\n  }\n  function pairs(values, pairof = pair) {\n    const pairs = [];\n    let previous;\n    let first = false;\n    for (const value of values) {\n      if (first) pairs.push(pairof(previous, value));\n      previous = value;\n      first = true;\n    }\n    return pairs;\n  }\n  function pair(a, b) {\n    return [a, b];\n  }\n  function range(start, stop, step) {\n    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n    var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n    while (++i < n) {\n      range[i] = start + i * step;\n    }\n    return range;\n  }\n  function least(values, compare = ascending) {\n    let min;\n    let defined = false;\n    if (compare.length === 1) {\n      let minValue;\n      for (const element of values) {\n        const value = compare(element);\n        if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {\n          min = element;\n          minValue = value;\n          defined = true;\n        }\n      }\n    } else {\n      for (const value of values) {\n        if (defined ? compare(value, min) < 0 : compare(value, value) === 0) {\n          min = value;\n          defined = true;\n        }\n      }\n    }\n    return min;\n  }\n  function leastIndex(values, compare = ascending) {\n    if (compare.length === 1) return minIndex(values, compare);\n    let minValue;\n    let min = -1;\n    let index = -1;\n    for (const value of values) {\n      ++index;\n      if (min < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n        minValue = value;\n        min = index;\n      }\n    }\n    return min;\n  }\n  function greatest(values, compare = ascending) {\n    let max;\n    let defined = false;\n    if (compare.length === 1) {\n      let maxValue;\n      for (const element of values) {\n        const value = compare(element);\n        if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {\n          max = element;\n          maxValue = value;\n          defined = true;\n        }\n      }\n    } else {\n      for (const value of values) {\n        if (defined ? compare(value, max) > 0 : compare(value, value) === 0) {\n          max = value;\n          defined = true;\n        }\n      }\n    }\n    return max;\n  }\n  function greatestIndex(values, compare = ascending) {\n    if (compare.length === 1) return maxIndex(values, compare);\n    let maxValue;\n    let max = -1;\n    let index = -1;\n    for (const value of values) {\n      ++index;\n      if (max < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {\n        maxValue = value;\n        max = index;\n      }\n    }\n    return max;\n  }\n  function scan(values, compare) {\n    const index = leastIndex(values, compare);\n    return index < 0 ? undefined : index;\n  }\n  var shuffle = shuffler(Math.random);\n  function shuffler(random) {\n    return function shuffle(array, i0 = 0, i1 = array.length) {\n      let m = i1 - (i0 = +i0);\n      while (m) {\n        const i = random() * m-- | 0,\n          t = array[m + i0];\n        array[m + i0] = array[i + i0];\n        array[i + i0] = t;\n      }\n      return array;\n    };\n  }\n  function sum(values, valueof) {\n    let sum = 0;\n    if (valueof === undefined) {\n      for (let value of values) {\n        if (value = +value) {\n          sum += value;\n        }\n      }\n    } else {\n      let index = -1;\n      for (let value of values) {\n        if (value = +valueof(value, ++index, values)) {\n          sum += value;\n        }\n      }\n    }\n    return sum;\n  }\n  function transpose(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  }\n  function length(d) {\n    return d.length;\n  }\n  function zip() {\n    return transpose(arguments);\n  }\n  function every(values, test) {\n    if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n    let index = -1;\n    for (const value of values) {\n      if (!test(value, ++index, values)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function some(values, test) {\n    if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n    let index = -1;\n    for (const value of values) {\n      if (test(value, ++index, values)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function filter(values, test) {\n    if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n    const array = [];\n    let index = -1;\n    for (const value of values) {\n      if (test(value, ++index, values)) {\n        array.push(value);\n      }\n    }\n    return array;\n  }\n  function map(values, mapper) {\n    if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n    if (typeof mapper !== \"function\") throw new TypeError(\"mapper is not a function\");\n    return Array.from(values, (value, index) => mapper(value, index, values));\n  }\n  function reduce(values, reducer, value) {\n    if (typeof reducer !== \"function\") throw new TypeError(\"reducer is not a function\");\n    const iterator = values[Symbol.iterator]();\n    let done,\n      next,\n      index = -1;\n    if (arguments.length < 3) {\n      ({\n        done,\n        value\n      } = iterator.next());\n      if (done) return;\n      ++index;\n    }\n    while (({\n      done,\n      value: next\n    } = iterator.next()), !done) {\n      value = reducer(value, next, ++index, values);\n    }\n    return value;\n  }\n  function reverse(values) {\n    if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n    return Array.from(values).reverse();\n  }\n  function difference(values, ...others) {\n    values = new Set(values);\n    for (const other of others) {\n      for (const value of other) {\n        values.delete(value);\n      }\n    }\n    return values;\n  }\n  function disjoint(values, other) {\n    const iterator = other[Symbol.iterator](),\n      set = new Set();\n    for (const v of values) {\n      if (set.has(v)) return false;\n      let value, done;\n      while (({\n        value,\n        done\n      } = iterator.next())) {\n        if (done) break;\n        if (Object.is(v, value)) return false;\n        set.add(value);\n      }\n    }\n    return true;\n  }\n  function set(values) {\n    return values instanceof Set ? values : new Set(values);\n  }\n  function intersection(values, ...others) {\n    values = new Set(values);\n    others = others.map(set);\n    out: for (const value of values) {\n      for (const other of others) {\n        if (!other.has(value)) {\n          values.delete(value);\n          continue out;\n        }\n      }\n    }\n    return values;\n  }\n  function superset(values, other) {\n    const iterator = values[Symbol.iterator](),\n      set = new Set();\n    for (const o of other) {\n      if (set.has(o)) continue;\n      let value, done;\n      while (({\n        value,\n        done\n      } = iterator.next())) {\n        if (done) return false;\n        set.add(value);\n        if (Object.is(o, value)) break;\n      }\n    }\n    return true;\n  }\n  function subset(values, other) {\n    return superset(other, values);\n  }\n  function union(...others) {\n    const set = new Set();\n    for (const other of others) {\n      for (const o of other) {\n        set.add(o);\n      }\n    }\n    return set;\n  }\n  exports.Adder = Adder;\n  exports.InternMap = InternMap;\n  exports.InternSet = InternSet;\n  exports.ascending = ascending;\n  exports.bin = bin;\n  exports.bisect = bisectRight;\n  exports.bisectCenter = bisectCenter;\n  exports.bisectLeft = bisectLeft;\n  exports.bisectRight = bisectRight;\n  exports.bisector = bisector;\n  exports.count = count;\n  exports.cross = cross;\n  exports.cumsum = cumsum;\n  exports.descending = descending;\n  exports.deviation = deviation;\n  exports.difference = difference;\n  exports.disjoint = disjoint;\n  exports.every = every;\n  exports.extent = extent;\n  exports.fcumsum = fcumsum;\n  exports.filter = filter;\n  exports.fsum = fsum;\n  exports.greatest = greatest;\n  exports.greatestIndex = greatestIndex;\n  exports.group = group;\n  exports.groupSort = groupSort;\n  exports.groups = groups;\n  exports.histogram = bin;\n  exports.index = index;\n  exports.indexes = indexes;\n  exports.intersection = intersection;\n  exports.least = least;\n  exports.leastIndex = leastIndex;\n  exports.map = map;\n  exports.max = max;\n  exports.maxIndex = maxIndex;\n  exports.mean = mean;\n  exports.median = median;\n  exports.merge = merge;\n  exports.min = min;\n  exports.minIndex = minIndex;\n  exports.nice = nice;\n  exports.pairs = pairs;\n  exports.permute = permute;\n  exports.quantile = quantile;\n  exports.quantileSorted = quantileSorted;\n  exports.quickselect = quickselect;\n  exports.range = range;\n  exports.reduce = reduce;\n  exports.reverse = reverse;\n  exports.rollup = rollup;\n  exports.rollups = rollups;\n  exports.scan = scan;\n  exports.shuffle = shuffle;\n  exports.shuffler = shuffler;\n  exports.some = some;\n  exports.sort = sort;\n  exports.subset = subset;\n  exports.sum = sum;\n  exports.superset = superset;\n  exports.thresholdFreedmanDiaconis = freedmanDiaconis;\n  exports.thresholdScott = scott;\n  exports.thresholdSturges = sturges;\n  exports.tickIncrement = tickIncrement;\n  exports.tickStep = tickStep;\n  exports.ticks = ticks;\n  exports.transpose = transpose;\n  exports.union = union;\n  exports.variance = variance;\n  exports.zip = zip;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","d3","ascending","a","b","NaN","bisector","f","delta","compare","length","d","x","ascendingComparator","left","lo","hi","mid","right","center","i","number","numbers","values","valueof","undefined","value","index","ascendingBisect","bisectRight","bisectLeft","bisectCenter","count","length$1","array","empty","arrayify","Array","from","reducer","reduce","cross","pop","map","lengths","j","fill","product","some","push","cumsum","sum","Float64Array","v","descending","variance","mean","deviation","Math","sqrt","extent","min","max","Adder","constructor","_partials","_n","add","p","y","abs","valueOf","n","fsum","adder","fcumsum","InternMap","Map","entries","key","keyof","Object","defineProperties","_intern","_key","set","get","intern_get","has","intern_set","delete","intern_delete","InternSet","Set","identity","group","keys","nest","groups","rollup","rollups","unique","indexes","Error","regroup","permute","source","sort","F","Symbol","iterator","TypeError","Uint32Array","c","groupSort","ak","av","bk","bv","prototype","slice","constant","e10","e5","e2","ticks","start","stop","reverse","step","tickIncrement","isFinite","r0","round","r1","power","floor","log","LN10","error","pow","tickStep","step0","step1","nice","prestep","ceil","sturges","LN2","bin","domain","threshold","histogram","data","isArray","xz","x0","x1","tz","tn","m","shift","bins","_","arguments","thresholds","call","quickselect","k","z","s","exp","sd","newLeft","newRight","t","swap","quantile","i0","value0","subarray","value1","quantileSorted","freedmanDiaconis","scott","maxIndex","median","flatten","arrays","merge","minIndex","pairs","pairof","pair","previous","first","range","least","defined","minValue","element","leastIndex","greatest","maxValue","greatestIndex","scan","shuffle","shuffler","random","i1","transpose","matrix","row","zip","every","test","filter","mapper","done","next","difference","others","other","disjoint","is","intersection","out","superset","o","subset","union","bisect","thresholdFreedmanDiaconis","thresholdScott","thresholdSturges","defineProperty"],"sources":["/Users/fneffati/Documents/Classes/TBRTD/frontend/node_modules/d3-array/dist/d3-array.js"],"sourcesContent":["// https://d3js.org/d3-array/ v2.12.1 Copyright 2021 Mike Bostock\n(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.d3 = global.d3 || {}));\n}(this, (function (exports) { 'use strict';\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisector(f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n\nfunction number(x) {\n  return x === null ? NaN : +x;\n}\n\nfunction* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n\nconst ascendingBisect = bisector(ascending);\nconst bisectRight = ascendingBisect.right;\nconst bisectLeft = ascendingBisect.left;\nconst bisectCenter = bisector(number).center;\n\nfunction count(values, valueof) {\n  let count = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n\nfunction length$1(array) {\n  return array.length | 0;\n}\n\nfunction empty(length) {\n  return !(length > 0);\n}\n\nfunction arrayify(values) {\n  return typeof values !== \"object\" || \"length\" in values ? values : Array.from(values);\n}\n\nfunction reducer(reduce) {\n  return values => reduce(...values);\n}\n\nfunction cross(...values) {\n  const reduce = typeof values[values.length - 1] === \"function\" && reducer(values.pop());\n  values = values.map(arrayify);\n  const lengths = values.map(length$1);\n  const j = values.length - 1;\n  const index = new Array(j + 1).fill(0);\n  const product = [];\n  if (j < 0 || lengths.some(empty)) return product;\n  while (true) {\n    product.push(index.map((j, i) => values[i][j]));\n    let i = j;\n    while (++index[i] === lengths[i]) {\n      if (i === 0) return reduce ? product.map(reduce) : product;\n      index[i--] = 0;\n    }\n  }\n}\n\nfunction cumsum(values, valueof) {\n  var sum = 0, index = 0;\n  return Float64Array.from(values, valueof === undefined\n    ? v => (sum += +v || 0)\n    : v => (sum += +valueof(v, index++, values) || 0));\n}\n\nfunction descending(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n\nfunction variance(values, valueof) {\n  let count = 0;\n  let delta;\n  let mean = 0;\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        delta = value - mean;\n        mean += delta / ++count;\n        sum += delta * (value - mean);\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        delta = value - mean;\n        mean += delta / ++count;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n  if (count > 1) return sum / (count - 1);\n}\n\nfunction deviation(values, valueof) {\n  const v = variance(values, valueof);\n  return v ? Math.sqrt(v) : v;\n}\n\nfunction extent(values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n}\n\n// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423\nclass Adder {\n  constructor() {\n    this._partials = new Float64Array(32);\n    this._n = 0;\n  }\n  add(x) {\n    const p = this._partials;\n    let i = 0;\n    for (let j = 0; j < this._n && j < 32; j++) {\n      const y = p[j],\n        hi = x + y,\n        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);\n      if (lo) p[i++] = lo;\n      x = hi;\n    }\n    p[i] = x;\n    this._n = i + 1;\n    return this;\n  }\n  valueOf() {\n    const p = this._partials;\n    let n = this._n, x, y, lo, hi = 0;\n    if (n > 0) {\n      hi = p[--n];\n      while (n > 0) {\n        x = hi;\n        y = p[--n];\n        hi = x + y;\n        lo = y - (hi - x);\n        if (lo) break;\n      }\n      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {\n        y = lo * 2;\n        x = hi + y;\n        if (y == x - hi) hi = x;\n      }\n    }\n    return hi;\n  }\n}\n\nfunction fsum(values, valueof) {\n  const adder = new Adder();\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value = +value) {\n        adder.add(value);\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if (value = +valueof(value, ++index, values)) {\n        adder.add(value);\n      }\n    }\n  }\n  return +adder;\n}\n\nfunction fcumsum(values, valueof) {\n  const adder = new Adder();\n  let index = -1;\n  return Float64Array.from(values, valueof === undefined\n      ? v => adder.add(+v || 0)\n      : v => adder.add(+valueof(v, ++index, values) || 0)\n  );\n}\n\nclass InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nclass InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(value);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nfunction group(values, ...keys) {\n  return nest(values, identity, identity, keys);\n}\n\nfunction groups(values, ...keys) {\n  return nest(values, Array.from, identity, keys);\n}\n\nfunction rollup(values, reduce, ...keys) {\n  return nest(values, identity, reduce, keys);\n}\n\nfunction rollups(values, reduce, ...keys) {\n  return nest(values, Array.from, reduce, keys);\n}\n\nfunction index(values, ...keys) {\n  return nest(values, identity, unique, keys);\n}\n\nfunction indexes(values, ...keys) {\n  return nest(values, Array.from, unique, keys);\n}\n\nfunction unique(values) {\n  if (values.length !== 1) throw new Error(\"duplicate key\");\n  return values[0];\n}\n\nfunction nest(values, map, reduce, keys) {\n  return (function regroup(values, i) {\n    if (i >= keys.length) return reduce(values);\n    const groups = new InternMap();\n    const keyof = keys[i++];\n    let index = -1;\n    for (const value of values) {\n      const key = keyof(value, ++index, values);\n      const group = groups.get(key);\n      if (group) group.push(value);\n      else groups.set(key, [value]);\n    }\n    for (const [key, values] of groups) {\n      groups.set(key, regroup(values, i));\n    }\n    return map(groups);\n  })(values, 0);\n}\n\nfunction permute(source, keys) {\n  return Array.from(keys, key => source[key]);\n}\n\nfunction sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f = ascending] = F;\n  if (f.length === 1 || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map(f => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascending(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascending(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(f);\n}\n\nfunction groupSort(values, reduce, key) {\n  return (reduce.length === 1\n    ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)))\n    : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))))\n    .map(([key]) => key);\n}\n\nvar array = Array.prototype;\n\nvar slice = array.slice;\n\nfunction constant(x) {\n  return function() {\n    return x;\n  };\n}\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction ticks(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step), r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step), r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nfunction nice(start, stop, count) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start, stop, count);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n\nfunction sturges(values) {\n  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;\n}\n\nfunction bin() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    if (!Array.isArray(data)) data = Array.from(data);\n\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds, and nice the\n    // default domain accordingly.\n    if (!Array.isArray(tz)) {\n      const max = x1, tn = +tz;\n      if (domain === extent) [x0, x1] = nice(x0, x1, tn);\n      tz = ticks(x0, x1, tn);\n\n      // If the last threshold is coincident with the domain’s upper bound, the\n      // last bin will be zero-width. If the default domain is used, and this\n      // last threshold is coincident with the maximum input value, we can\n      // extend the niced upper bound by one tick to ensure uniform bin widths;\n      // otherwise, we simply remove the last threshold. Note that we don’t\n      // coerce values or the domain to numbers, and thus must be careful to\n      // compare order (>=) rather than strict equality (===)!\n      if (tz[tz.length - 1] >= x1) {\n        if (max >= x1 && domain === extent) {\n          const step = tickIncrement(x0, x1, tn);\n          if (isFinite(step)) {\n            if (step > 0) {\n              x1 = (Math.floor(x1 / step) + 1) * step;\n            } else if (step < 0) {\n              x1 = (Math.ceil(x1 * -step) + 1) / -step;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n\nfunction max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n\nfunction min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n\n// Based on https://github.com/mourner/quickselect\n// ISC license, Copyright 2018 Vladimir Agafonkin.\nfunction quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {\n  while (right > left) {\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(array, k, newLeft, newRight, compare);\n    }\n\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    swap(array, left, k);\n    if (compare(array[right], t) > 0) swap(array, left, right);\n\n    while (i < j) {\n      swap(array, i, j), ++i, --j;\n      while (compare(array[i], t) < 0) ++i;\n      while (compare(array[j], t) > 0) --j;\n    }\n\n    if (compare(array[left], t) === 0) swap(array, left, j);\n    else ++j, swap(array, j, right);\n\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n  return array;\n}\n\nfunction swap(array, i, j) {\n  const t = array[i];\n  array[i] = array[j];\n  array[j] = t;\n}\n\nfunction quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nfunction quantileSorted(values, p, valueof = number) {\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nfunction freedmanDiaconis(values, min, max) {\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));\n}\n\nfunction scott(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));\n}\n\nfunction maxIndex(values, valueof) {\n  let max;\n  let maxIndex = -1;\n  let index = -1;\n  if (valueof === undefined) {\n    for (const value of values) {\n      ++index;\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value, maxIndex = index;\n      }\n    }\n  } else {\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value, maxIndex = index;\n      }\n    }\n  }\n  return maxIndex;\n}\n\nfunction mean(values, valueof) {\n  let count = 0;\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        ++count, sum += value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        ++count, sum += value;\n      }\n    }\n  }\n  if (count) return sum / count;\n}\n\nfunction median(values, valueof) {\n  return quantile(values, 0.5, valueof);\n}\n\nfunction* flatten(arrays) {\n  for (const array of arrays) {\n    yield* array;\n  }\n}\n\nfunction merge(arrays) {\n  return Array.from(flatten(arrays));\n}\n\nfunction minIndex(values, valueof) {\n  let min;\n  let minIndex = -1;\n  let index = -1;\n  if (valueof === undefined) {\n    for (const value of values) {\n      ++index;\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value, minIndex = index;\n      }\n    }\n  } else {\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value, minIndex = index;\n      }\n    }\n  }\n  return minIndex;\n}\n\nfunction pairs(values, pairof = pair) {\n  const pairs = [];\n  let previous;\n  let first = false;\n  for (const value of values) {\n    if (first) pairs.push(pairof(previous, value));\n    previous = value;\n    first = true;\n  }\n  return pairs;\n}\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\nfunction range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n\nfunction least(values, compare = ascending) {\n  let min;\n  let defined = false;\n  if (compare.length === 1) {\n    let minValue;\n    for (const element of values) {\n      const value = compare(element);\n      if (defined\n          ? ascending(value, minValue) < 0\n          : ascending(value, value) === 0) {\n        min = element;\n        minValue = value;\n        defined = true;\n      }\n    }\n  } else {\n    for (const value of values) {\n      if (defined\n          ? compare(value, min) < 0\n          : compare(value, value) === 0) {\n        min = value;\n        defined = true;\n      }\n    }\n  }\n  return min;\n}\n\nfunction leastIndex(values, compare = ascending) {\n  if (compare.length === 1) return minIndex(values, compare);\n  let minValue;\n  let min = -1;\n  let index = -1;\n  for (const value of values) {\n    ++index;\n    if (min < 0\n        ? compare(value, value) === 0\n        : compare(value, minValue) < 0) {\n      minValue = value;\n      min = index;\n    }\n  }\n  return min;\n}\n\nfunction greatest(values, compare = ascending) {\n  let max;\n  let defined = false;\n  if (compare.length === 1) {\n    let maxValue;\n    for (const element of values) {\n      const value = compare(element);\n      if (defined\n          ? ascending(value, maxValue) > 0\n          : ascending(value, value) === 0) {\n        max = element;\n        maxValue = value;\n        defined = true;\n      }\n    }\n  } else {\n    for (const value of values) {\n      if (defined\n          ? compare(value, max) > 0\n          : compare(value, value) === 0) {\n        max = value;\n        defined = true;\n      }\n    }\n  }\n  return max;\n}\n\nfunction greatestIndex(values, compare = ascending) {\n  if (compare.length === 1) return maxIndex(values, compare);\n  let maxValue;\n  let max = -1;\n  let index = -1;\n  for (const value of values) {\n    ++index;\n    if (max < 0\n        ? compare(value, value) === 0\n        : compare(value, maxValue) > 0) {\n      maxValue = value;\n      max = index;\n    }\n  }\n  return max;\n}\n\nfunction scan(values, compare) {\n  const index = leastIndex(values, compare);\n  return index < 0 ? undefined : index;\n}\n\nvar shuffle = shuffler(Math.random);\n\nfunction shuffler(random) {\n  return function shuffle(array, i0 = 0, i1 = array.length) {\n    let m = i1 - (i0 = +i0);\n    while (m) {\n      const i = random() * m-- | 0, t = array[m + i0];\n      array[m + i0] = array[i + i0];\n      array[i + i0] = t;\n    }\n    return array;\n  };\n}\n\nfunction sum(values, valueof) {\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value = +value) {\n        sum += value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if (value = +valueof(value, ++index, values)) {\n        sum += value;\n      }\n    }\n  }\n  return sum;\n}\n\nfunction transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n\nfunction zip() {\n  return transpose(arguments);\n}\n\nfunction every(values, test) {\n  if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n  let index = -1;\n  for (const value of values) {\n    if (!test(value, ++index, values)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction some(values, test) {\n  if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n  let index = -1;\n  for (const value of values) {\n    if (test(value, ++index, values)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction filter(values, test) {\n  if (typeof test !== \"function\") throw new TypeError(\"test is not a function\");\n  const array = [];\n  let index = -1;\n  for (const value of values) {\n    if (test(value, ++index, values)) {\n      array.push(value);\n    }\n  }\n  return array;\n}\n\nfunction map(values, mapper) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  if (typeof mapper !== \"function\") throw new TypeError(\"mapper is not a function\");\n  return Array.from(values, (value, index) => mapper(value, index, values));\n}\n\nfunction reduce(values, reducer, value) {\n  if (typeof reducer !== \"function\") throw new TypeError(\"reducer is not a function\");\n  const iterator = values[Symbol.iterator]();\n  let done, next, index = -1;\n  if (arguments.length < 3) {\n    ({done, value} = iterator.next());\n    if (done) return;\n    ++index;\n  }\n  while (({done, value: next} = iterator.next()), !done) {\n    value = reducer(value, next, ++index, values);\n  }\n  return value;\n}\n\nfunction reverse(values) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  return Array.from(values).reverse();\n}\n\nfunction difference(values, ...others) {\n  values = new Set(values);\n  for (const other of others) {\n    for (const value of other) {\n      values.delete(value);\n    }\n  }\n  return values;\n}\n\nfunction disjoint(values, other) {\n  const iterator = other[Symbol.iterator](), set = new Set();\n  for (const v of values) {\n    if (set.has(v)) return false;\n    let value, done;\n    while (({value, done} = iterator.next())) {\n      if (done) break;\n      if (Object.is(v, value)) return false;\n      set.add(value);\n    }\n  }\n  return true;\n}\n\nfunction set(values) {\n  return values instanceof Set ? values : new Set(values);\n}\n\nfunction intersection(values, ...others) {\n  values = new Set(values);\n  others = others.map(set);\n  out: for (const value of values) {\n    for (const other of others) {\n      if (!other.has(value)) {\n        values.delete(value);\n        continue out;\n      }\n    }\n  }\n  return values;\n}\n\nfunction superset(values, other) {\n  const iterator = values[Symbol.iterator](), set = new Set();\n  for (const o of other) {\n    if (set.has(o)) continue;\n    let value, done;\n    while (({value, done} = iterator.next())) {\n      if (done) return false;\n      set.add(value);\n      if (Object.is(o, value)) break;\n    }\n  }\n  return true;\n}\n\nfunction subset(values, other) {\n  return superset(other, values);\n}\n\nfunction union(...others) {\n  const set = new Set();\n  for (const other of others) {\n    for (const o of other) {\n      set.add(o);\n    }\n  }\n  return set;\n}\n\nexports.Adder = Adder;\nexports.InternMap = InternMap;\nexports.InternSet = InternSet;\nexports.ascending = ascending;\nexports.bin = bin;\nexports.bisect = bisectRight;\nexports.bisectCenter = bisectCenter;\nexports.bisectLeft = bisectLeft;\nexports.bisectRight = bisectRight;\nexports.bisector = bisector;\nexports.count = count;\nexports.cross = cross;\nexports.cumsum = cumsum;\nexports.descending = descending;\nexports.deviation = deviation;\nexports.difference = difference;\nexports.disjoint = disjoint;\nexports.every = every;\nexports.extent = extent;\nexports.fcumsum = fcumsum;\nexports.filter = filter;\nexports.fsum = fsum;\nexports.greatest = greatest;\nexports.greatestIndex = greatestIndex;\nexports.group = group;\nexports.groupSort = groupSort;\nexports.groups = groups;\nexports.histogram = bin;\nexports.index = index;\nexports.indexes = indexes;\nexports.intersection = intersection;\nexports.least = least;\nexports.leastIndex = leastIndex;\nexports.map = map;\nexports.max = max;\nexports.maxIndex = maxIndex;\nexports.mean = mean;\nexports.median = median;\nexports.merge = merge;\nexports.min = min;\nexports.minIndex = minIndex;\nexports.nice = nice;\nexports.pairs = pairs;\nexports.permute = permute;\nexports.quantile = quantile;\nexports.quantileSorted = quantileSorted;\nexports.quickselect = quickselect;\nexports.range = range;\nexports.reduce = reduce;\nexports.reverse = reverse;\nexports.rollup = rollup;\nexports.rollups = rollups;\nexports.scan = scan;\nexports.shuffle = shuffle;\nexports.shuffler = shuffler;\nexports.some = some;\nexports.sort = sort;\nexports.subset = subset;\nexports.sum = sum;\nexports.superset = superset;\nexports.thresholdFreedmanDiaconis = freedmanDiaconis;\nexports.thresholdScott = scott;\nexports.thresholdSturges = sturges;\nexports.tickIncrement = tickIncrement;\nexports.tickStep = tickStep;\nexports.ticks = ticks;\nexports.transpose = transpose;\nexports.union = union;\nexports.variance = variance;\nexports.zip = zip;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}