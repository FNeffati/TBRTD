{"ast":null,"code":"import { Selection } from \"./index\";\nimport { EnterNode } from \"./enter\";\nimport constant from \"../constant\";\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n    node,\n    groupLength = group.length,\n    dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n    node,\n    nodeByKeyValue = {},\n    groupLength = group.length,\n    dataLength = data.length,\n    keyValues = new Array(groupLength),\n    keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {\n      exit[i] = node;\n    }\n  }\n}\nexport default function (value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function (d) {\n      data[++j] = d;\n    });\n    return data;\n  }\n  var bind = key ? bindKey : bindIndex,\n    parents = this._parents,\n    groups = this._groups;\n  if (typeof value !== \"function\") value = constant(value);\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n      group = groups[j],\n      groupLength = group.length,\n      data = value.call(parent, parent && parent.__data__, j, parents),\n      dataLength = data.length,\n      enterGroup = enter[j] = new Array(dataLength),\n      updateGroup = update[j] = new Array(dataLength),\n      exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}","map":{"version":3,"names":["Selection","EnterNode","constant","keyPrefix","bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","length","dataLength","__data__","bindKey","key","nodeByKeyValue","keyValues","Array","keyValue","call","value","size","j","each","d","bind","parents","_parents","groups","_groups","m","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","_next","_enter","_exit"],"sources":["/Users/fneffati/Documents/Classes/TBRTD/frontend/node_modules/d3-selection/src/selection/data.js"],"sourcesContent":["import {Selection} from \"./index\";\nimport {EnterNode} from \"./enter\";\nimport constant from \"../constant\";\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}