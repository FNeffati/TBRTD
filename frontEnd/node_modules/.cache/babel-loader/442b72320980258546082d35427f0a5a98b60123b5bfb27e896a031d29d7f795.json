{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n\n/**\n * @fileoverview DataHandler implementation for the errorBars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport BarsHandler from './bars';\n\n/**\n * @constructor\n * @extends BarsHandler\n */\nvar ErrorBarsHandler = function () {};\nErrorBarsHandler.prototype = new BarsHandler();\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  const seriesLabel = options.get(\"labels\")[i];\n  const logScale = options.getForSeries(\"logscale\", seriesLabel);\n  const sigma = options.getForSeries(\"sigma\", seriesLabel);\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[0];\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1];\n        // preserve original error value in extras for further\n        // filtering\n        series.push([x, y, [y - variance, y + variance, point[1]]]);\n      } else {\n        series.push([x, y, [y, y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options, i) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  const seriesLabel = options.get(\"labels\")[i];\n  const sigma = options.getForSeries(\"sigma\", seriesLabel);\n  var i, j, y, v, sum, num_ok, stddev, variance, value;\n\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];\n    } else {\n      // This explicitly preserves NaNs to aid with \"independent\n      // series\".\n      // See testRollingAveragePreservesNaNs.\n      v = rollPeriod == 1 ? originalData[i][1] : null;\n      rollingData[i] = [originalData[i][0], v, [v, v]];\n    }\n  }\n  return rollingData;\n};\nexport default ErrorBarsHandler;","map":{"version":3,"names":["BarsHandler","ErrorBarsHandler","prototype","extractSeries","rawData","i","options","series","x","y","variance","point","seriesLabel","get","logScale","getForSeries","sigma","j","length","isNaN","push","rollingAverage","originalData","rollPeriod","Math","min","rollingData","v","sum","num_ok","stddev","value","max","pow","sqrt"],"sources":["/Users/fneffati/Documents/Classes/TBENVDASH/frontEnd/tbenv/node_modules/dygraphs/src/datahandler/bars-error.js"],"sourcesContent":["/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n\n/**\n * @fileoverview DataHandler implementation for the errorBars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport BarsHandler from './bars';\n\n/**\n * @constructor\n * @extends BarsHandler\n */\nvar ErrorBarsHandler = function() {\n};\n\nErrorBarsHandler.prototype = new BarsHandler();\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  const seriesLabel = options.get(\"labels\")[i];\n  const logScale = options.getForSeries(\"logscale\", seriesLabel);\n  const sigma = options.getForSeries(\"sigma\", seriesLabel);\n  for ( var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[0];\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1];\n        // preserve original error value in extras for further\n        // filtering\n        series.push([ x, y, [ y - variance, y + variance, point[1] ] ]);\n      } else {\n        series.push([ x, y, [ y, y, y ] ]);\n      }\n    } else {\n      series.push([ x, null, [ null, null, null ] ]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.rollingAverage =\n    function(originalData, rollPeriod, options, i) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  const seriesLabel = options.get(\"labels\")[i];\n  const sigma = options.getForSeries(\"sigma\", seriesLabel);\n\n  var i, j, y, v, sum, num_ok, stddev, variance, value;\n\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y))\n        continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [ originalData[i][0], value,\n          [value - sigma * stddev, value + sigma * stddev] ];\n    } else {\n      // This explicitly preserves NaNs to aid with \"independent\n      // series\".\n      // See testRollingAveragePreservesNaNs.\n      v = (rollPeriod == 1) ? originalData[i][1] : null;\n      rollingData[i] = [ originalData[i][0], v, [ v, v ] ];\n    }\n  }\n\n  return rollingData;\n};\n\nexport default ErrorBarsHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}