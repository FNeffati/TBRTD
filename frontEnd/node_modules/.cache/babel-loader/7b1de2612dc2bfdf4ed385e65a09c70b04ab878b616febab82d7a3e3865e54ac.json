{"ast":null,"code":"//     wink-lemmatizer\n//     English lemmatizer\n//\n//     This file is part of “wink-lemmatizer”.\n//\n//     Copyright (c) GRAYPE Systems Private Limited\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n// Load adjective/noun/verb exceptions.\nconst adjectiveExceptions = require('wink-lexicon/src/wn-adjective-exceptions.js');\nconst nounExceptions = require('wink-lexicon/src/wn-noun-exceptions.js');\nconst verbExceptions = require('wink-lexicon/src/wn-verb-exceptions.js');\n// Load all words (base form),\nconst words = require('wink-lexicon/src/wn-words.js');\n// and their senses.\nconst senseMap = require('wink-lexicon/src/wn-word-senses.js');\n// The name space.\nconst lemmatize = Object.create(null);\n\n// The following code is an adaptation of [WordNet's Morphy](https://wordnet.princeton.edu/documentation/morphy7wn):\n\n// ### isAdjective\n/**\n * Checks the word in base form is an adjective or not using wordnet senses.\n *\n * @private\n * @method isAdjective\n * @param {string} word that needs to be tested for adjective.\n * @return {boolean} `true` if word is a valid adjective otherwise `false.`\n * @example\n * isAdjective( 'lat' );\n * // -> false\n*/\nvar isAdjective = function (word) {\n  const index = words[word];\n  if (index === undefined) return false;\n  const senses = senseMap[index];\n  for (let k = 0; k < senses.length; k += 1) {\n    if (senses[k] < 2) return true;\n  }\n  return false;\n}; // isAdjective()\n\n// ### lemmatizeAdjective\n/**\n *\n * Conjugates an `adjective` to it's base form (VB). It also has an alias\n * `lemmatizeAdjective` to maintain API level compatibility with previous version.\n *\n * @method adjective\n * @param {string} adjective that needs to be conjugated to base form.\n * @return {string} the base form of `adjective`.\n * @example\n * lemmatize.adjective( 'farthest' );\n * // -> far\n*/\nlemmatize.adjective = function (adjective) {\n  var lemma = adjectiveExceptions[adjective];\n  if (lemma) return lemma;\n  lemma = adjective.replace(/est$|er$/, '');\n  if (lemma.length === adjective.length) return adjective;\n  if (isAdjective(lemma)) return lemma;\n  lemma += 'e';\n  if (isAdjective(lemma)) return lemma;\n  return adjective;\n}; // adjective()\n\n// ### isVerb\n/**\n * Checks the word in base form is a verb or not using wordnet senses.\n *\n * @private\n * @method isVerb\n * @param {string} word that needs to be tested for verb.\n * @return {boolean} `true` if word is a valid verb otherwise `false.`\n * @example\n * isVerb( 'eat' );\n * // -> true\n*/\nvar isVerb = function (word) {\n  const index = words[word];\n  if (index === undefined) return false;\n  const senses = senseMap[index];\n  for (let k = 0; k < senses.length; k += 1) {\n    if (senses[k] > 28 && senses[k] < 44) return true;\n  }\n  return false;\n}; // isVerb()\n\n// ### lemmatizeVerb\n/**\n *\n * Conjugates a `verb` to it's base form (VB). It also has an alias\n * `lemmatizeVerb` to maintain API level compatibility with previous version.\n *\n * @method verb\n * @param {string} verb that needs to be conjugated to base form.\n * @return {string} the base form of `verb`.\n * @example\n * lemmatize.verb( 'winning' );\n * // -> win\n*/\nlemmatize.verb = function (verb) {\n  var lemma = verbExceptions[verb];\n  if (lemma) return lemma;\n  lemma = verb.replace(/s$/, '');\n  if (lemma.length !== verb.length && isVerb(lemma)) return lemma;\n  lemma = verb.replace(/ies$/, 'y');\n  if (lemma.length !== verb.length && isVerb(lemma)) return lemma;\n  lemma = verb.replace(/es$|ed$|ing$/, '');\n  if (lemma.length !== verb.length) {\n    if (isVerb(lemma)) return lemma;\n    lemma += 'e';\n    if (isVerb(lemma)) return lemma;\n  }\n  return verb;\n}; // verb()\n\nconst nounRegexes = [{\n  replace: /s$/,\n  by: ''\n}, {\n  replace: /ses$/,\n  by: 's'\n}, {\n  replace: /xes$/,\n  by: 'x'\n}, {\n  replace: /zes$/,\n  by: 's'\n}, {\n  replace: /ves$/,\n  by: 'f'\n}, {\n  replace: /ches$/,\n  by: 'ch'\n}, {\n  replace: /shes$/,\n  by: 'sh'\n}, {\n  replace: /men$/,\n  by: 'man'\n}, {\n  replace: /ies$/,\n  by: 'y'\n}];\n\n// ### isNoun\n/**\n * Checks the word in base form is a noun or not using wordnet senses.\n *\n * @private\n * @method isNoun\n * @param {string} word that needs to be tested for noun.\n * @return {boolean} `true` if word is a valid noun otherwise `false.`\n * @example\n * isAdjective( 'house' );\n * // -> true\n*/\nvar isNoun = function (word) {\n  const index = words[word];\n  if (index === undefined) return false;\n  const senses = senseMap[index];\n  for (let k = 0; k < senses.length; k += 1) {\n    if (senses[k] > 2 && senses[k] < 29) return true;\n  }\n  return false;\n}; // isNoun()\n\n// ### lemmatizeNoun\n/**\n *\n * Converts the input `noun` to it's singular form. It also has an alias\n * `lemmatizeNoun` to maintain API level compatibility with previous version.\n *\n * @method noun\n * @param {string} noun that needs to be lemmatized.\n * @return {string} the singular of `noun`.\n * @example\n * lemmatize.noun( 'handkerchieves' );\n * // -> handkerchief\n*/\nlemmatize.noun = function (noun) {\n  var lemma = nounExceptions[noun];\n  if (lemma) return lemma;\n  lemma = noun;\n  for (let k = 0; k < nounRegexes.length; k += 1) {\n    lemma = noun.replace(nounRegexes[k].replace, nounRegexes[k].by);\n    if (lemma.length !== noun.length && isNoun(lemma)) return lemma;\n  }\n  return noun;\n}; // noun()\n\n// Create alias to maintain backwards compatibility.\nlemmatize.lemmatizeNoun = lemmatize.noun;\nlemmatize.lemmatizeVerb = lemmatize.verb;\nlemmatize.lemmatizeAdjective = lemmatize.adjective;\nmodule.exports = lemmatize;","map":{"version":3,"names":["adjectiveExceptions","require","nounExceptions","verbExceptions","words","senseMap","lemmatize","Object","create","isAdjective","word","index","undefined","senses","k","length","adjective","lemma","replace","isVerb","verb","nounRegexes","by","isNoun","noun","lemmatizeNoun","lemmatizeVerb","lemmatizeAdjective","module","exports"],"sources":["/Users/fneffati/Documents/Classes/TBRTD/frontend/node_modules/wink-lemmatizer/src/wink-lemmatizer.js"],"sourcesContent":["//     wink-lemmatizer\n//     English lemmatizer\n//\n//     This file is part of “wink-lemmatizer”.\n//\n//     Copyright (c) GRAYPE Systems Private Limited\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n// Load adjective/noun/verb exceptions.\nconst adjectiveExceptions = require( 'wink-lexicon/src/wn-adjective-exceptions.js' );\nconst nounExceptions = require( 'wink-lexicon/src/wn-noun-exceptions.js' );\nconst verbExceptions = require( 'wink-lexicon/src/wn-verb-exceptions.js' );\n// Load all words (base form),\nconst words = require( 'wink-lexicon/src/wn-words.js' );\n// and their senses.\nconst senseMap = require( 'wink-lexicon/src/wn-word-senses.js' );\n// The name space.\nconst lemmatize = Object.create( null );\n\n// The following code is an adaptation of [WordNet's Morphy](https://wordnet.princeton.edu/documentation/morphy7wn):\n\n// ### isAdjective\n/**\n * Checks the word in base form is an adjective or not using wordnet senses.\n *\n * @private\n * @method isAdjective\n * @param {string} word that needs to be tested for adjective.\n * @return {boolean} `true` if word is a valid adjective otherwise `false.`\n * @example\n * isAdjective( 'lat' );\n * // -> false\n*/\nvar isAdjective = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] < 2 ) return true;\n  }\n  return false;\n}; // isAdjective()\n\n// ### lemmatizeAdjective\n/**\n *\n * Conjugates an `adjective` to it's base form (VB). It also has an alias\n * `lemmatizeAdjective` to maintain API level compatibility with previous version.\n *\n * @method adjective\n * @param {string} adjective that needs to be conjugated to base form.\n * @return {string} the base form of `adjective`.\n * @example\n * lemmatize.adjective( 'farthest' );\n * // -> far\n*/\nlemmatize.adjective = function ( adjective ) {\n  var lemma = adjectiveExceptions[ adjective ];\n  if ( lemma ) return lemma;\n  lemma = adjective.replace( /est$|er$/, '' );\n  if ( lemma.length === adjective.length ) return adjective;\n  if ( isAdjective( lemma ) ) return lemma;\n  lemma += 'e';\n  if ( isAdjective( lemma ) ) return lemma;\n  return adjective;\n}; // adjective()\n\n// ### isVerb\n/**\n * Checks the word in base form is a verb or not using wordnet senses.\n *\n * @private\n * @method isVerb\n * @param {string} word that needs to be tested for verb.\n * @return {boolean} `true` if word is a valid verb otherwise `false.`\n * @example\n * isVerb( 'eat' );\n * // -> true\n*/\nvar isVerb = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] > 28 && senses[ k ] < 44  ) return true;\n  }\n  return false;\n}; // isVerb()\n\n// ### lemmatizeVerb\n/**\n *\n * Conjugates a `verb` to it's base form (VB). It also has an alias\n * `lemmatizeVerb` to maintain API level compatibility with previous version.\n *\n * @method verb\n * @param {string} verb that needs to be conjugated to base form.\n * @return {string} the base form of `verb`.\n * @example\n * lemmatize.verb( 'winning' );\n * // -> win\n*/\nlemmatize.verb = function ( verb ) {\n  var lemma = verbExceptions[ verb ];\n  if ( lemma ) return lemma;\n\n  lemma = verb.replace( /s$/, '' );\n  if ( lemma.length !== verb.length && isVerb( lemma ) ) return lemma;\n\n  lemma = verb.replace( /ies$/, 'y' );\n  if ( lemma.length !== verb.length && isVerb( lemma ) ) return lemma;\n\n  lemma = verb.replace( /es$|ed$|ing$/, '' );\n    if ( lemma.length !== verb.length ) {\n    if ( isVerb( lemma ) ) return lemma;\n    lemma += 'e';\n    if ( isVerb( lemma ) ) return lemma;\n  }\n  return verb;\n}; // verb()\n\nconst nounRegexes = [\n  { replace: /s$/, by: '' },\n  { replace: /ses$/, by: 's' },\n  { replace: /xes$/, by: 'x' },\n  { replace: /zes$/, by: 's' },\n  { replace: /ves$/, by: 'f' },\n  { replace: /ches$/, by: 'ch' },\n  { replace: /shes$/, by: 'sh' },\n  { replace: /men$/, by: 'man' },\n  { replace: /ies$/, by: 'y' }\n];\n\n// ### isNoun\n/**\n * Checks the word in base form is a noun or not using wordnet senses.\n *\n * @private\n * @method isNoun\n * @param {string} word that needs to be tested for noun.\n * @return {boolean} `true` if word is a valid noun otherwise `false.`\n * @example\n * isAdjective( 'house' );\n * // -> true\n*/\nvar isNoun = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] > 2 && senses[ k ] < 29  ) return true;\n  }\n  return false;\n}; // isNoun()\n\n// ### lemmatizeNoun\n/**\n *\n * Converts the input `noun` to it's singular form. It also has an alias\n * `lemmatizeNoun` to maintain API level compatibility with previous version.\n *\n * @method noun\n * @param {string} noun that needs to be lemmatized.\n * @return {string} the singular of `noun`.\n * @example\n * lemmatize.noun( 'handkerchieves' );\n * // -> handkerchief\n*/\nlemmatize.noun = function ( noun ) {\n  var lemma = nounExceptions[ noun ];\n  if ( lemma ) return lemma;\n\n  lemma = noun;\n  for ( let k = 0; k < nounRegexes.length; k += 1 ) {\n    lemma = noun.replace( nounRegexes[ k ].replace, nounRegexes[ k ].by );\n\n    if ( lemma.length !== noun.length && isNoun( lemma ) ) return lemma;\n  }\n\n  return noun;\n}; // noun()\n\n// Create alias to maintain backwards compatibility.\nlemmatize.lemmatizeNoun = lemmatize.noun;\nlemmatize.lemmatizeVerb = lemmatize.verb;\nlemmatize.lemmatizeAdjective = lemmatize.adjective;\n\nmodule.exports = lemmatize;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}