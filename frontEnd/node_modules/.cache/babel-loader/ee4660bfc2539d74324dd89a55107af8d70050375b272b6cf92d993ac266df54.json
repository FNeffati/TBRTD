{"ast":null,"code":"/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport * as utils from '../dygraph-utils';\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function () {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false; // do we own this div, or was it user-specified?\n};\nLegend.prototype.toString = function () {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function (g) {\n  var div;\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof userLabelsDiv == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n  this.legend_div_ = div;\n  this.one_em_width_ = 10; // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function (div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth = sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\nvar escapeHTML = function (str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&#34;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\nLegend.prototype.select = function (e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  if (html instanceof Node && html.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    this.legend_div_.innerHTML = '';\n    this.legend_div_.appendChild(html);\n  } else this.legend_div_.innerHTML = html;\n  // must be done now so offsetWidth isn’t 0…\n  this.legend_div_.style.display = '';\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // find the closest data point by checking the currently highlighted series,\n    // or fall back to using the first data point available\n    var highlightSeries = e.dygraph.getHighlightSeries();\n    var point;\n    if (highlightSeries) {\n      point = points.find(p => p.name === highlightSeries);\n      if (!point) point = points[0];\n    } else point = points[0];\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    const followOffsetX = e.dygraph.getNumericOption('legendFollowOffsetX');\n    const followOffsetY = e.dygraph.getNumericOption('legendFollowOffsetY');\n    var leftLegend = point.x * area.w + followOffsetX;\n    var topLegend = point.y * area.h + followOffsetY;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if (leftLegend + labelsDivWidth + 1 > area.w) {\n      leftLegend = leftLegend - 2 * followOffsetX - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  } else if (legendMode === 'onmouseover' && this.is_generated_div_) {\n    // synchronise this with Legend.prototype.predraw below\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n    this.legend_div_.style.top = area.y + \"px\";\n  }\n};\nLegend.prototype.deselect = function (e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  if (html instanceof Node && html.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    this.legend_div_.innerHTML = '';\n    this.legend_div_.appendChild(html);\n  } else this.legend_div_.innerHTML = html;\n};\nLegend.prototype.didDrawChart = function (e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes).\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function (e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  // synchronise this with Legend.prototype.select above\n  var area = e.dygraph.plotter_.area;\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function () {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    i: row,\n    series: []\n  };\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n  if (typeof x !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n      utils.update(seriesData, {\n        yHTML\n      });\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;\n  return formatter.call(g, data);\n};\nLegend.defaultFormatter = function (data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n  if (typeof data.x === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n      if (html !== '') html += sepLines ? '<br />' : ' ';\n      html += \"<span style='font-weight: bold; color: \".concat(series.color, \";'>\").concat(series.dashHTML, \" \").concat(series.labelHTML, \"</span>\");\n    }\n    return html;\n  }\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.y && !series.yHTML) continue;\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += \"<span\".concat(cls, \"> <b><span style='color: \").concat(series.color, \";'>\").concat(series.labelHTML, \"</span></b>:&#160;\").concat(series.yHTML, \"</span>\");\n  }\n  return html;\n};\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return \"<div class=\\\"dygraph-legend-line\\\" style=\\\"border-bottom-color: \".concat(color, \";\\\"></div>\");\n  }\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0,\n    segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice,\n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i % strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length + 1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i += 2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i % normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += \"<div class=\\\"dygraph-legend-dash\\\" style=\\\"margin-right: \".concat(marginRight, \"em; padding-left: \").concat(paddingLeft, \"em;\\\"></div>\");\n    }\n  }\n  return dash;\n}\nexport default Legend;","map":{"version":3,"names":["utils","Legend","legend_div_","is_generated_div_","prototype","toString","activate","g","div","userLabelsDiv","getOption","String","document","getElementById","createElement","className","graphDiv","appendChild","one_em_width_","select","deselect","predraw","didDrawChart","calculateEmWidthInDiv","sizeSpan","setAttribute","oneEmWidth","offsetWidth","removeChild","escapeHTML","str","replace","e","xValue","selectedX","points","selectedPoints","row","selectedRow","legendMode","dygraph","style","display","html","generateLegendHTML","Node","nodeType","DOCUMENT_FRAGMENT_NODE","innerHTML","area","plotter_","labelsDivWidth","yAxisLabelWidth","getOptionForAxis","highlightSeries","getHighlightSeries","point","find","p","name","followOffsetX","getNumericOption","followOffsetY","leftLegend","x","w","topLegend","y","h","left","top","undefined","destroy","sel_points","data","i","series","labelToSeries","labels","getLabels","length","getPropertiesForSeries","strokePattern","seriesData","dashHTML","generateLegendDashHTML","color","label","labelHTML","isVisible","visible","push","xOptView","optionsViewForAxis_","xvf","xHTML","call","yOptViews","num_axes","numAxes","showZeros","pt","yval","isNaN","canvasy","yOptView","axis","fmtFunc","yHTML","indexOf","update","isHighlighted","formatter","defaultFormatter","sepLines","concat","cls","j","paddingLeft","marginRight","strokePixelLength","segmentLoop","normalizedPattern","loop","Math","floor","dash"],"sources":["/Users/fneffati/Documents/Classes/TBENVDASH/frontEnd/tbenv/node_modules/dygraphs/src/plugins/legend.js"],"sourcesContent":["/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport * as utils from '../dygraph-utils';\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false;  // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function() {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function(g) {\n  var div;\n\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof(userLabelsDiv) == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10;  // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth=sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&#34;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function(e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  if (html instanceof Node && html.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    this.legend_div_.innerHTML = '';\n    this.legend_div_.appendChild(html);\n  } else\n    this.legend_div_.innerHTML = html;\n  // must be done now so offsetWidth isn’t 0…\n  this.legend_div_.style.display = '';\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // find the closest data point by checking the currently highlighted series,\n    // or fall back to using the first data point available\n    var highlightSeries = e.dygraph.getHighlightSeries()\n    var point;\n    if (highlightSeries) {\n      point = points.find(p => p.name === highlightSeries);\n      if (!point)\n        point = points[0];\n    } else\n      point = points[0];\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    const followOffsetX = e.dygraph.getNumericOption('legendFollowOffsetX');\n    const followOffsetY = e.dygraph.getNumericOption('legendFollowOffsetY');\n    var leftLegend = point.x * area.w + followOffsetX;\n    var topLegend  = point.y * area.h + followOffsetY;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if ((leftLegend + labelsDivWidth + 1) > area.w) {\n      leftLegend = leftLegend - 2 * followOffsetX - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  } else if (legendMode === 'onmouseover' && this.is_generated_div_) {\n    // synchronise this with Legend.prototype.predraw below\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n    this.legend_div_.style.top = area.y + \"px\";\n  }\n};\n\nLegend.prototype.deselect = function(e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  if (html instanceof Node && html.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    this.legend_div_.innerHTML = '';\n    this.legend_div_.appendChild(html);\n  } else\n    this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function(e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes).\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function(e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  // synchronise this with Legend.prototype.select above\n  var area = e.dygraph.plotter_.area;\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function() {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function(g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    i: row,\n    series: []\n  };\n\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof(x) !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if ((pt.yval === 0 && !showZeros) || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n\n      utils.update(seriesData, {yHTML});\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = (g.getOption('legendFormatter') || Legend.defaultFormatter);\n  return formatter.call(g, data);\n}\n\nLegend.defaultFormatter = function(data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof(data.x) === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n\n      if (html !== '') html += (sepLines ? '<br />' : ' ');\n      html += `<span style='font-weight: bold; color: ${series.color};'>${series.dashHTML} ${series.labelHTML}</span>`;\n    }\n    return html;\n  }\n\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.y && !series.yHTML) continue;\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += `<span${cls}> <b><span style='color: ${series.color};'>${series.labelHTML}</span></b>:&#160;${series.yHTML}</span>`;\n  }\n  return html;\n};\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return `<div class=\"dygraph-legend-line\" style=\"border-bottom-color: ${color};\"></div>`;\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0, segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice,\n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i%strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth/(strokePixelLength-strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length+1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i+=2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i%normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i+1)%normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += `<div class=\"dygraph-legend-dash\" style=\"margin-right: ${marginRight}em; padding-left: ${paddingLeft}em;\"></div>`;\n    }\n  }\n  return dash;\n}\n\nexport default Legend;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}