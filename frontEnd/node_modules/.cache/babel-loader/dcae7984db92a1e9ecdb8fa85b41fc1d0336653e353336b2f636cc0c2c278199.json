{"ast":null,"code":"/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - high/low bands\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It's based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport * as utils from './dygraph-utils';\nimport Dygraph from './dygraph';\n\n/**\n * @constructor\n *\n * This gets called when there are \"new points\" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart's DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\nvar DygraphCanvasRenderer = function (dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n  this.height = dygraph.height_;\n  this.width = dygraph.width_;\n\n  // --- check whether everything is ok before we return\n  if (!utils.isCanvasSupported(this.element)) {\n    throw \"Canvas is not supported.\";\n  }\n\n  // internal state\n  this.area = layout.getPlotArea();\n\n  // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don't overdraw.\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\nDygraphCanvasRenderer.prototype.clear = function () {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, high/low bands, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\nDygraphCanvasRenderer.prototype.render = function () {\n  // attaches point.canvas{x,y}\n  this._updatePoints();\n\n  // actually draws the chart.\n  this._renderLineChart();\n};\n\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it's false, the predicate will\n * skip over points with missing yVals.\n */\nDygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {\n  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;\n};\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {\n  return array[idx].yval !== null;\n};\n\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {\n  var g = e.dygraph;\n  // TODO(konigsberg): Compute attributes outside this method call.\n  var stepPlot = g.getBooleanOption(\"stepPlot\", e.setName);\n  if (!utils.isArrayLike(strokePattern)) {\n    strokePattern = null;\n  }\n  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);\n  var points = e.points;\n  var setName = e.setName;\n  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n  var stroking = strokePattern && strokePattern.length >= 2;\n  var ctx = e.drawingContext;\n  ctx.save();\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n  ctx.restore();\n};\n\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n  var point; // the point being processed in the while loop\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth;\n\n  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n      if (i == limit) break;\n      point = arr[i];\n    }\n\n    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test\n    // doesn't catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;\n        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;\n        if (drawGapPoints) {\n          // Also consider a point to be \"isolated\" if it's adjacent to a\n          // null point, excluding the graph edges.\n          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {\n            isIsolated = true;\n          }\n        }\n      }\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n    first = false;\n  }\n  ctx.stroke();\n  return pointsOnLine;\n};\n\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the \"drawPoints\" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\nDygraphCanvasRenderer.prototype._updatePoints = function () {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can't specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n\n/**\n * Add canvas Actually draw the lines chart, including high/low bands.\n *\n * This function can only be called if DygraphLayout's points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object's\n *     elementContext.\n * @private\n */\nDygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n  this.colors = this.dygraph_.colorsMap_;\n\n  // Determine which series have specialized plotters.\n  var plotter_attr = this.dygraph_.getOption(\"plotter\");\n  var plotters = plotter_attr;\n  if (!utils.isArrayLike(plotters)) {\n    plotters = [plotters];\n  }\n  var setPlotters = {}; // series name -> plotter fn.\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption(\"plotter\", setName);\n    if (setPlotter == plotter_attr) continue; // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = i == plotters.length - 1;\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n      var points = sets[j];\n\n      // Only throw in the specialized plotters on the last iteration.\n      var p = plotter;\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don't use the standard plotters in this case.\n          continue;\n        }\n      }\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption(\"strokeWidth\", setName);\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function (e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n  fillPlotter: function (e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n  errorPlotter: function (e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\nDygraphCanvasRenderer._linePlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth;\n\n  // TODO(danvk): Check if there's any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) || utils.Circles.DEFAULT;\n  var strokePattern = g.getOption(\"strokePattern\", setName);\n  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n  var pointSize = g.getNumericOption(\"pointSize\", setName);\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e, g.getOption(\"strokeBorderColor\", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n  }\n  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n};\n\n/**\n * Draws the shaded high/low bands (confidence intervals) for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the high/low bands for all series.\n * @private\n */\nDygraphCanvasRenderer._errorPlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption(\"errorBars\") || g.getBooleanOption(\"customBars\");\n  if (!errorBars) return;\n  var fillGraph = g.getBooleanOption(\"fillGraph\", setName);\n  if (fillGraph) {\n    console.warn(\"Can't use fillGraph option with customBars or errorBars option\");\n  }\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption('fillAlpha', setName);\n  var stepPlot = g.getBooleanOption(\"stepPlot\", setName);\n  var points = e.points;\n  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n  var newYs;\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1];\n  // should be same color as the lines but only 15% opaque.\n  var rgb = utils.toRGB_(color);\n  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n  var isNullUndefinedOrNaN = function (x) {\n    return x === null || x === undefined || isNaN(x);\n  };\n  while (iter.hasNext) {\n    var point = iter.next();\n    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {\n      prevX = NaN;\n      continue;\n    }\n    newYs = [point.y_bottom, point.y_top];\n    if (stepPlot) {\n      prevY = point.y;\n    }\n\n    // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n  ctx.fill();\n};\n\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven't changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\nDygraphCanvasRenderer._fastCanvasProxy = function (context) {\n  var pendingActions = []; // array of [type, x, y] tuples\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n  var LINE_TO = 1,\n    MOVE_TO = 2;\n  var actionCount = 0; // number of moveTos and lineTos passed to context.\n\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n  var compressActions = function (opt_losslessOnly) {\n    if (pendingActions.length <= 1) return;\n\n    // Lossless compression: drop inconsequential moveTos.\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    }\n\n    // Lossless compression: ... drop consecutive moveTos ...\n    for /* incremented internally */\n    (var i = 0; i < pendingActions.length - 1;) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Lossy compression: ... drop all but the extreme y-values ...\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null,\n        maxIdx = null;\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n      var minAction = pendingActions[minIdx],\n        maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n  var flushActions = function (opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n  var addAction = function (action, x, y) {\n    var rx = Math.round(x);\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it's essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,\n        hasGapOnRight = rx - lastRoundedX > 1,\n        hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n    pendingActions.push([action, x, y]);\n  };\n  return {\n    moveTo: function (x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function (x, y) {\n      addAction(LINE_TO, x, y);\n    },\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke: function () {\n      flushActions(true);\n      context.stroke();\n    },\n    fill: function () {\n      flushActions(true);\n      context.fill();\n    },\n    beginPath: function () {\n      flushActions(true);\n      context.beginPath();\n    },\n    closePath: function () {\n      flushActions(true);\n      context.closePath();\n    },\n    _count: function () {\n      return actionCount;\n    }\n  };\n};\n\n/**\n * Draws the shaded regions when \"fillGraph\" is set.\n * Not to be confused with high/low bands (historically misnamed errorBars).\n *\n * For stacked charts, it's more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it's asked to draw, then ignores all the other series.\n *\n * @private\n */\nDygraphCanvasRenderer._fillPlotter = function (e) {\n  // Skip if we're drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return;\n\n  // We'll handle all the series at once, not one-by-one.\n  if (e.seriesIndex !== 0) return;\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1); // remove x-axis\n\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n  var anySeriesFilled = function () {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption(\"fillGraph\", setNames[i])) return true;\n    }\n    return false;\n  }();\n  if (!anySeriesFilled) return;\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot; // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function (ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  // process sets in reverse order (needed for stacked graphs)\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption('fillGraph', setName)) continue;\n    var fillAlpha = g.getNumericOption('fillAlpha', setName);\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n    var points = sets[setIdx];\n    var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    // setup graphics context\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs;\n    // should be same color as the lines but only 15% opaque.\n    var rgb = utils.toRGB_(color);\n    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x,\n      is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this \"back path\" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n    var pathBack = [];\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!utils.isOK(point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if (prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n        newYs = [point.canvasy, lastY];\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [point.canvasy, axisY];\n          } else {\n            baseline[point.canvasx] = [point.canvasy, prevYs[0]];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [area.y + area.h, axisY];\n        } else {\n          newYs = [point.canvasy, axisY];\n        }\n      }\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n        // Record the baseline for the reverse path.\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n  }\n};\nexport default DygraphCanvasRenderer;","map":{"version":3,"names":["utils","Dygraph","DygraphCanvasRenderer","dygraph","element","elementContext","layout","dygraph_","height","height_","width","width_","isCanvasSupported","area","getPlotArea","ctx","canvas_ctx_","beginPath","rect","x","y","w","h","clip","hidden_ctx_","prototype","clear","clearRect","render","_updatePoints","_renderLineChart","_getIteratorPredicate","connectSeparatedPoints","_predicateThatSkipsEmptyPoints","array","idx","yval","_drawStyledLine","e","color","strokeWidth","strokePattern","drawPoints","drawPointCallback","pointSize","g","stepPlot","getBooleanOption","setName","isArrayLike","drawGapPoints","points","iter","createIterator","length","stroking","drawingContext","save","setLineDash","pointsOnLine","_drawSeries","_drawPointsOnLine","restore","prevCanvasX","prevCanvasY","nextCanvasY","isIsolated","point","first","strokeStyle","lineWidth","arr","array_","limit","end_","predicate","predicate_","i","start_","canvasy","moveTo","lineTo","canvasx","nextIdx_","next","hasNext","peek","isNextCanvasYNullOrNaN","push","stroke","cb","call","sets","j","opt_seriesName","opt_ctx","setNames","colors","colorsMap_","plotter_attr","getOption","plotters","setPlotters","setPlotter","plotter","is_last","p","axis","axisPropertiesForSeries","plotArea","seriesIndex","seriesCount","singleSeriesName","allSeriesPoints","_Plotters","linePlotter","_linePlotter","fillPlotter","_fillPlotter","errorPlotter","_errorPlotter","borderWidth","getNumericOption","Circles","DEFAULT","errorBars","fillGraph","console","warn","fillAlpha","newYs","prevX","NaN","prevY","prevYs","rgb","toRGB_","err_color","r","b","fillStyle","isNullUndefinedOrNaN","undefined","isNaN","y_bottom","y_top","closePath","fill","_fastCanvasProxy","context","pendingActions","lastRoundedX","lastFlushedX","LINE_TO","MOVE_TO","actionCount","compressActions","opt_losslessOnly","action","prevAction","splice","startIdx","minIdx","maxIdx","minAction","maxAction","flushActions","opt_noLossyCompression","len","addAction","rx","Math","round","hasGapOnLeft","hasGapOnRight","hasGap","_count","getLabels","slice","visibility","anySeriesFilled","setCount","stackedGraph","getColors","baseline","currBaseline","prevStepPlot","traceBackPath","baselineX","baselineY","pathBack","pt","setIdx","axisY","minyval","yscale","last_x","is_first","FORCE_FAST_PROXY","isOK","y_stacked","xval","lastY"],"sources":["/Users/fneffati/Documents/Classes/TBRTD/frontend/node_modules/dygraphs/src/dygraph-canvas.js"],"sourcesContent":["/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licenced: https://opensource.org/licenses/MIT\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - high/low bands\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It's based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nimport * as utils from './dygraph-utils';\nimport Dygraph from './dygraph';\n\n/**\n * @constructor\n *\n * This gets called when there are \"new points\" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart's DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\nvar DygraphCanvasRenderer = function(dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n\n  this.height = dygraph.height_;\n  this.width = dygraph.width_;\n\n  // --- check whether everything is ok before we return\n  if (!utils.isCanvasSupported(this.element)) {\n    throw \"Canvas is not supported.\";\n  }\n\n  // internal state\n  this.area = layout.getPlotArea();\n\n  // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don't overdraw.\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\nDygraphCanvasRenderer.prototype.clear = function() {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, high/low bands, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\nDygraphCanvasRenderer.prototype.render = function() {\n  // attaches point.canvas{x,y}\n  this._updatePoints();\n\n  // actually draws the chart.\n  this._renderLineChart();\n};\n\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it's false, the predicate will\n * skip over points with missing yVals.\n */\nDygraphCanvasRenderer._getIteratorPredicate = function(connectSeparatedPoints) {\n  return connectSeparatedPoints ?\n      DygraphCanvasRenderer._predicateThatSkipsEmptyPoints :\n      null;\n};\n\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints =\n    function(array, idx) {\n  return array[idx].yval !== null;\n};\n\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawStyledLine = function(e,\n    color, strokeWidth, strokePattern, drawPoints,\n    drawPointCallback, pointSize) {\n  var g = e.dygraph;\n  // TODO(konigsberg): Compute attributes outside this method call.\n  var stepPlot = g.getBooleanOption(\"stepPlot\", e.setName);\n\n  if (!utils.isArrayLike(strokePattern)) {\n    strokePattern = null;\n  }\n\n  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);\n\n  var points = e.points;\n  var setName = e.setName;\n  var iter = utils.createIterator(points, 0, points.length,\n      DygraphCanvasRenderer._getIteratorPredicate(\n          g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var stroking = strokePattern && (strokePattern.length >= 2);\n\n  var ctx = e.drawingContext;\n  ctx.save();\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(\n      e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n  DygraphCanvasRenderer._drawPointsOnLine(\n      e, pointsOnLine, drawPointCallback, color, pointSize);\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n\n  ctx.restore();\n};\n\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawSeries = function(e,\n    iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n  var point; // the point being processed in the while loop\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth;\n\n  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n      if (i == limit) break;\n      point = arr[i];\n    }\n\n    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test\n    // doesn't catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n\n        var isNextCanvasYNullOrNaN = nextCanvasY === null ||\n            nextCanvasY != nextCanvasY;\n        isIsolated = (prevCanvasX === null && isNextCanvasYNullOrNaN);\n        if (drawGapPoints) {\n          // Also consider a point to be \"isolated\" if it's adjacent to a\n          // null point, excluding the graph edges.\n          if ((!first && prevCanvasX === null) ||\n              (iter.hasNext && isNextCanvasYNullOrNaN)) {\n            isIsolated = true;\n          }\n        }\n      }\n\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n    first = false;\n  }\n  ctx.stroke();\n  return pointsOnLine;\n};\n\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the \"drawPoints\" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawPointsOnLine = function(\n    e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph,\n        e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\nDygraphCanvasRenderer.prototype._updatePoints = function() {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can't specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n\n/**\n * Add canvas Actually draw the lines chart, including high/low bands.\n *\n * This function can only be called if DygraphLayout's points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object's\n *     elementContext.\n * @private\n */\nDygraphCanvasRenderer.prototype._renderLineChart = function(opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n\n  this.colors = this.dygraph_.colorsMap_;\n\n  // Determine which series have specialized plotters.\n  var plotter_attr = this.dygraph_.getOption(\"plotter\");\n  var plotters = plotter_attr;\n  if (!utils.isArrayLike(plotters)) {\n    plotters = [plotters];\n  }\n\n  var setPlotters = {};  // series name -> plotter fn.\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption(\"plotter\", setName);\n    if (setPlotter == plotter_attr) continue;  // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = (i == plotters.length - 1);\n\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n\n      var points = sets[j];\n\n      // Only throw in the specialized plotters on the last iteration.\n      var p = plotter;\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don't use the standard plotters in this case.\n          continue;\n        }\n      }\n\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption(\"strokeWidth\", setName);\n\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function(e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n\n  fillPlotter: function(e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n\n  errorPlotter: function(e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\nDygraphCanvasRenderer._linePlotter = function(e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth;\n\n  // TODO(danvk): Check if there's any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n      utils.Circles.DEFAULT;\n  var strokePattern = g.getOption(\"strokePattern\", setName);\n  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e,\n        g.getOption(\"strokeBorderColor\", setName),\n        strokeWidth + 2 * borderWidth,\n        strokePattern,\n        drawPoints,\n        drawPointCallback,\n        pointSize\n        );\n  }\n\n  DygraphCanvasRenderer._drawStyledLine(e,\n      e.color,\n      strokeWidth,\n      strokePattern,\n      drawPoints,\n      drawPointCallback,\n      pointSize\n  );\n};\n\n/**\n * Draws the shaded high/low bands (confidence intervals) for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the high/low bands for all series.\n * @private\n */\nDygraphCanvasRenderer._errorPlotter = function(e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption(\"errorBars\") ||\n      g.getBooleanOption(\"customBars\");\n  if (!errorBars) return;\n\n  var fillGraph = g.getBooleanOption(\"fillGraph\", setName);\n  if (fillGraph) {\n    console.warn(\"Can't use fillGraph option with customBars or errorBars option\");\n  }\n\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption('fillAlpha', setName);\n  var stepPlot = g.getBooleanOption(\"stepPlot\", setName);\n  var points = e.points;\n\n  var iter = utils.createIterator(points, 0, points.length,\n      DygraphCanvasRenderer._getIteratorPredicate(\n          g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var newYs;\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1];\n  // should be same color as the lines but only 15% opaque.\n  var rgb = utils.toRGB_(color);\n  var err_color =\n      'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n\n  var isNullUndefinedOrNaN = function(x) {\n    return (x === null ||\n            x === undefined ||\n            isNaN(x));\n  };\n\n  while (iter.hasNext) {\n    var point = iter.next();\n    if ((!stepPlot && isNullUndefinedOrNaN(point.y)) ||\n        (stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY))) {\n      prevX = NaN;\n      continue;\n    }\n\n    newYs = [ point.y_bottom, point.y_top ];\n    if (stepPlot) {\n      prevY = point.y;\n    }\n\n    // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n  ctx.fill();\n};\n\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven't changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\nDygraphCanvasRenderer._fastCanvasProxy = function(context) {\n  var pendingActions = [];  // array of [type, x, y] tuples\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n\n  var LINE_TO = 1,\n      MOVE_TO = 2;\n\n  var actionCount = 0;  // number of moveTos and lineTos passed to context.\n\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n  var compressActions = function(opt_losslessOnly) {\n    if (pendingActions.length <= 1) return;\n\n    // Lossless compression: drop inconsequential moveTos.\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    }\n\n    // Lossless compression: ... drop consecutive moveTos ...\n    for (var i = 0; i < pendingActions.length - 1; /* incremented internally */) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Lossy compression: ... drop all but the extreme y-values ...\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null, maxIdx = null;\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n      var minAction = pendingActions[minIdx],\n          maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n\n  var flushActions = function(opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n\n  var addAction = function(action, x, y) {\n    var rx = Math.round(x);\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it's essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = (lastRoundedX - lastFlushedX > 1),\n          hasGapOnRight = (rx - lastRoundedX > 1),\n          hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n    pendingActions.push([action, x, y]);\n  };\n\n  return {\n    moveTo: function(x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function(x, y) {\n      addAction(LINE_TO, x, y);\n    },\n\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke:    function() { flushActions(true); context.stroke(); },\n    fill:      function() { flushActions(true); context.fill(); },\n    beginPath: function() { flushActions(true); context.beginPath(); },\n    closePath: function() { flushActions(true); context.closePath(); },\n\n    _count: function() { return actionCount; }\n  };\n};\n\n/**\n * Draws the shaded regions when \"fillGraph\" is set.\n * Not to be confused with high/low bands (historically misnamed errorBars).\n *\n * For stacked charts, it's more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it's asked to draw, then ignores all the other series.\n *\n * @private\n */\nDygraphCanvasRenderer._fillPlotter = function(e) {\n  // Skip if we're drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return;\n\n  // We'll handle all the series at once, not one-by-one.\n  if (e.seriesIndex !== 0) return;\n\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1);  // remove x-axis\n\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n\n  var anySeriesFilled = (function() {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption(\"fillGraph\", setNames[i])) return true;\n    }\n    return false;\n  })();\n\n  if (!anySeriesFilled) return;\n\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  // process sets in reverse order (needed for stacked graphs)\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption('fillGraph', setName)) continue;\n\n    var fillAlpha = g.getNumericOption('fillAlpha', setName);\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n    var points = sets[setIdx];\n    var iter = utils.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    // setup graphics context\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs;\n    // should be same color as the lines but only 15% opaque.\n    var rgb = utils.toRGB_(color);\n    var err_color =\n        'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this \"back path\" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n    var pathBack = [];\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!utils.isOK(point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if(prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n        newYs = [ point.canvasy, lastY ];\n\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [ point.canvasy, axisY ];\n          } else {\n            baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [ area.y + area.h, axisY ];\n        } else {\n          newYs = [ point.canvasy, axisY ];\n        }\n      }\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n        // Record the baseline for the reverse path.\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n  }\n};\n\nexport default DygraphCanvasRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}